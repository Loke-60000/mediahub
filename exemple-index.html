<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/logo_gadget_lab_notxt.png">
    <title>Media Hub - メディアハブ</title>
    <!-- Font Awesome pour les icônes (conservé) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- CropperJS CSS (conservé pour la fonctionnalité) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <!-- Polices Google -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        /* --- Reset CSS et Styles Globaux de Gadget Lab --- */
        html, body {
          margin: 0;
          padding: 0;
          height: 100%;
          width: 100%;
          overflow-x: hidden; /* Empêche le débordement horizontal */
        }

        body {
          position: relative; /* Important pour les éléments positionnés */
          min-height: 100vh;
          width: 100%;
          font-family: 'Noto Sans JP', sans-serif; /* Police de Gadget Lab */
          color: #FF7B00; /* Couleur principale de Gadget Lab */
          background-color: #000; /* Fond noir */
          display: flex;
          flex-direction: column;
        }

        /* --- Animations de Gadget Lab --- */
        @keyframes scanlines {
          0% { background-position: 0 0; }
          100% { background-position: 0 100%; }
        }
        @keyframes noise {
          0%, 100% { transform: translate(0,0); }
          10% { transform: translate(-1%,-1%); }
          20% { transform: translate(1%,1%); }
          30% { transform: translate(-2%,-2%); }
          40% { transform: translate(3%,3%); }
          50% { transform: translate(-3%,-3%); }
          60% { transform: translate(4%,4%); }
          70% { transform: translate(-4%,-4%); }
          80% { transform: translate(2%,2%); }
          90% { transform: translate(-3%,-3%); }
        }
        @keyframes blink {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.3; }
        }
        @keyframes glitch-anim {
          0% { clip-path: inset(80% 0 20% 0); transform: translate(-2px, 2px); }
          20% { clip-path: inset(20% 0 40% 0); transform: translate(-2px, -2px); }
          40% { clip-path: inset(60% 0 25% 0); transform: translate(1px, 1px); }
          60% { clip-path: inset(15% 0 75% 0); transform: translate(1px, -1px); }
          80% { clip-path: inset(35% 0 60% 0); transform: translate(-1px, -1px); }
          100% { clip-path: inset(45% 0 50% 0); transform: translate(2px, 2px); }
        }

        /* --- Structure et Effets VCR de Gadget Lab --- */
        .background-container {
          position: fixed; /* Fixé pour rester en arrière-plan */
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 0;
        }
        .background-image {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-size: cover;
          background-position: bottom;
          /* Image d'exemple - REMPLACEZ PAR VOTRE IMAGE */
          background-image: url('https://raw.githubusercontent.com/the-gadget-lab/Photos-Selec/refs/heads/photo/photos/japon/japon-34.jpg'); /* !! METTRE UNE IMAGE !! */
          filter: blur(5px) sepia(0.3) hue-rotate(320deg);
          opacity: 0.3; /* Opacité fixe car pas de JS pour la transition ici */
        }
        .vcr-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 1;
        }
        .scanlines {
          position: absolute; /* Changé de fixed à absolute pour être dans l'overlay */
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: linear-gradient( to bottom, rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.2) 51% );
          background-size: 100% 4px;
          z-index: 3; /* Au-dessus du bruit */
          opacity: 0.3;
          animation: scanlines 8s linear infinite;
        }
        .noise {
          position: absolute; /* Changé de fixed à absolute */
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 2; /* Sous les scanlines */
          opacity: 0.05;
        }
        .noise::before {
          content: "";
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 300%; /* Plus grand pour l'animation */
          background: repeating-radial-gradient(#000 0 0.0001%, #fff 0 0.0002%) 50% 0/2500px 2500px, repeating-conic-gradient(#000 0 0.0001%, #fff 0 0.0002%) 50% 50%/2500px 2500px;
          background-blend-mode: difference;
          animation: noise 0.2s infinite alternate;
        }
        .vignette {
          position: absolute; /* Changé de fixed à absolute */
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          box-shadow: inset 0 0 150px rgba(0, 0, 0, 0.9);
          z-index: 1; /* Sous le bruit et les scanlines */
        }

        /* --- Header Style Gadget Lab --- */
        .header {
          padding: 2rem 1rem; /* Moins de padding horizontal pour petits écrans */
          text-align: center;
          position: relative;
          z-index: 10;
          margin-top: 2rem; /* Réduit un peu */
        }
        .logo-container {
          text-align: center;
        }
        h1 {
          font-size: 4rem; /* Légèrement réduit */
          letter-spacing: 3px;
          margin-bottom: 0.5rem;
          text-shadow: 0 0 10px #FF7B00, 0 0 20px #FF7B00;
          font-weight: 700;
        }
        h2 {
          font-size: 2.5rem; /* Légèrement réduit */
          letter-spacing: 6px; /* Réduit */
          margin-bottom: 1.5rem;
          font-weight: 500;
        }
        .divergence-meter {
          font-size: 1rem; /* Légèrement réduit */
          padding: 0.6rem;
          background: rgba(0, 0, 0, 0.7);
          border: 1px solid #FF7B00;
          display: inline-block;
          border-radius: 4px;
          margin-top: 1rem;
          box-shadow: 0 0 15px rgba(255, 123, 0, 0.5);
        }

        /* --- Footer Style Gadget Lab --- */
        .footer {
          text-align: center;
          padding: 1.5rem 0; /* Réduit */
          margin-top: auto; /* Pousse le footer en bas */
          position: relative;
          z-index: 10;
        }
        .footer-text p {
          margin: 0.5rem 0;
        }
        .blink {
          animation: blink 2s infinite;
        }
        .small {
          font-size: 0.8rem;
          opacity: 0.7;
        }

        /* --- Effet Glitch (appliqué aux éléments avec la classe .glitch-element) --- */
        .glitch-element {
          position: relative; /* Nécessaire pour les pseudo-éléments */
          overflow: hidden; /* Empêche les débordements de glitch */
        }
        .glitch-element.active:before,
        .glitch-element.active:after {
          content: attr(data-text); /* Utilise le contenu textuel pour le glitch */
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          opacity: 0.8;
          pointer-events: none;
          background: inherit; /* Hérite du fond mais peut être surchargé */
          color: inherit; /* Hérite de la couleur */
          padding: inherit; /* Hérite du padding */
          border: inherit; /* Hérite de la bordure */
          z-index: 1; /* Pour être au-dessus du contenu normal */
        }
        .glitch-element.active:before {
          left: 2px;
          text-shadow: -1px 0 red;
          background-color: rgba(255, 0, 0, 0.05); /* Fond léger pour accentuer */
          animation: glitch-anim 0.4s infinite linear alternate-reverse;
        }
        .glitch-element.active:after {
          left: -2px;
          text-shadow: 1px 0 blue;
          background-color: rgba(0, 0, 255, 0.05); /* Fond léger pour accentuer */
          animation: glitch-anim 0.5s infinite linear alternate;
        }

        /* --- Style du Contenu Principal (Media Hub) --- */
        /* Conteneur principal - stabilise la largeur */
        .main-content-wrapper {
            max-width: 960px; /* Limite la largeur max */
            width: 100%; /* Largeur fixe à 100% du max-width */
            margin: 2rem auto; /* Centre horizontalement, espace en haut/bas */
            padding: 0 1rem; /* Espace sur les côtés */
            position: relative;
            z-index: 5; /* Au-dessus du fond, sous les overlays principaux si besoin */
            transition: none; /* Désactive les transitions */
            box-sizing: border-box; /* Inclut padding dans la largeur */
        }

        /* Pour la boîte de contenu principale qui contient les onglets */
        .content-box {
            background-color: rgba(0, 0, 0, 0.75);
            border: 1px solid #FF7B00;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 2rem;
            box-shadow: 0 0 15px rgba(255, 123, 0, 0.3);
            min-height: 400px; /* Hauteur minimale pour éviter le redimensionnement brutal */
            transition: none; /* Désactive toute transition héritée */
            width: 100%; /* Largeur fixe */
        }

        /* --- Style des Onglets --- */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #FF7B00;
            flex-wrap: wrap; /* Permet le retour à la ligne sur mobile */
        }
        .tab-btn {
            padding: 12px 10px;
            font-size: 0.9rem; /* Un peu plus petit */
            font-weight: 500;
            text-align: center;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            color: #FF7B00; /* Couleur texte onglet */
            cursor: pointer;
            transition: background-color 0.2s ease, opacity 0.2s ease; /* Transitions limitées */
            flex-grow: 1; /* Occupe l'espace disponible */
            opacity: 0.8;
        }
        .tab-btn:hover {
            background-color: rgba(255, 123, 0, 0.1);
            opacity: 1;
        }
        .tab-btn.active {
            font-weight: 700;
            border-bottom-color: #FF7B00;
            background-color: rgba(255, 123, 0, 0.05);
            opacity: 1;
            text-shadow: 0 0 5px #FF7B00;
        }
        .tab-btn i {
            margin-right: 5px;
        }
        /* Ajustement des couleurs d'icônes (optionnel, peut être simplifié) */
        .tab-btn[data-tab="youtube"] i { color: #FF7B00; }
        .tab-btn[data-tab="converter"] i { color: #FF7B00; }
        .tab-btn[data-tab="cropper"] i { color: #FF7B00; }
        .tab-btn[data-tab="square-center"] i { color: #FF7B00; }

        .tab-content {
            padding: 1.5rem; /* Espace intérieur des contenus d'onglets */
            width: 100%; /* Largeur fixe */
            box-sizing: border-box; /* Inclut padding dans la largeur */
            position: relative; /* Position relative pour les contenus */
            /* Pas de transition ici pour éviter l'effet de redimensionnement */
        }
        .tab-content.hidden {
            display: none;
        }

        /* --- Style des Formulaires (Inputs, Selects, Labels) --- */
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: rgba(255, 123, 0, 0.8); /* Orange plus doux pour les labels */
        }
        input[type="url"],
        input[type="text"],
        select {
            width: 100%;
            padding: 0.6rem 0.8rem;
            border: 1px solid #FF7B00;
            background-color: rgba(0, 0, 0, 0.8);
            color: #FF7B00;
            border-radius: 3px;
            font-size: 0.9rem;
            margin-bottom: 1rem; /* Espace sous les inputs */
            transition: box-shadow 0.2s ease;
            box-sizing: border-box; /* Inclut padding et bordure dans la largeur */
        }
        input[type="url"]:focus,
        input[type="text"]:focus,
        select:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(255, 123, 0, 0.5);
            border-color: #FF7B00;
        }
        select {
            appearance: none; /* Supprime le style par défaut */
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FF7B00%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 0.7em top 50%;
            background-size: 0.65em auto;
            padding-right: 2.5em; /* Espace pour la flèche */
        }
        /* Style pour le conteneur flex autour de l'input URL */
        .url-input-container {
            display: flex;
            margin-bottom: 1.5rem; /* Espace sous le groupe input+bouton */
        }
        .url-input-container input[type="url"] {
             border-top-right-radius: 0;
             border-bottom-right-radius: 0;
             border-right: none; /* Évite double bordure */
             margin-bottom: 0; /* Pas de marge en bas dans le conteneur flex */
        }
        .url-input-container button {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            white-space: nowrap; /* Empêche le texte du bouton de passer à la ligne */
        }

        /* --- Style des Boutons --- */
        button, .button-style { /* Classe générique pour appliquer le style */
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #FF7B00;
            padding: 0.6rem 1.2rem;
            color: #FF7B00;
            text-decoration: none;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            letter-spacing: 1px;
            cursor: pointer;
            border-radius: 3px;
            display: inline-flex; /* Pour aligner icône et texte */
            align-items: center;
            justify-content: center;
            font-family: inherit; /* Hérite la police Noto Sans JP */
        }
        button:hover, .button-style:hover {
            background-color: rgba(255, 123, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 123, 0, 0.5);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: rgba(50, 50, 50, 0.7); /* Gris foncé désactivé */
            border-color: rgba(255, 123, 0, 0.3);
            color: rgba(255, 123, 0, 0.5);
        }
        button i.fa-spinner {
            margin-left: 8px;
        }
        .hidden { /* Utilitaire simple pour cacher/montrer via JS */
            display: none !important;
        }

        /* --- Style pour les sections d'infos (Vidéo, Fichier Convert) --- */
        .info-box {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border: 1px solid rgba(255, 123, 0, 0.5);
            border-radius: 4px;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
        }
        #video-thumbnail { /* Garde la structure, change le style */
            width: 100px; /* Taille fixe pour la vignette */
            height: 75px;
            background-color: rgba(255, 123, 0, 0.1);
            border: 1px dashed rgba(255, 123, 0, 0.4);
            border-radius: 3px;
            margin-right: 1rem;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }
        #video-info h3, #converter-file-info h3 { /* Style pour les titres d'info */
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.2rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px; /* Limite pour éviter les débordements */
        }
        #video-info p, #converter-file-info p { /* Style pour les détails d'info */
            font-size: 0.8rem;
            color: rgba(255, 123, 0, 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #converter-file-info-icon { /* Icône type de fichier */
             font-size: 2rem;
             margin-right: 1rem;
             color: rgba(255, 123, 0, 0.8);
             flex-shrink: 0;
        }
        #converter-remove-file { /* Bouton supprimer fichier */
             background: none;
             border: none;
             color: #FF7B00;
             opacity: 0.7;
             margin-left: auto; /* Pousse à droite */
             padding: 5px;
             cursor: pointer;
             font-size: 1.2rem;
        }
         #converter-remove-file:hover {
             opacity: 1;
             color: red; /* Indicateur de suppression */
         }

        /* --- Style pour les listes de Tâches (Downloads/Conversions) --- */
        .tasks-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 123, 0, 0.3);
            padding-bottom: 0.5rem;
        }
         .tasks-list-header h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0;
         }
         .tasks-list-header h3 i {
             margin-right: 8px;
             opacity: 0.8;
         }
         .tasks-list-header button {
             padding: 0.3rem 0.6rem; /* Plus petits boutons */
             font-size: 0.8rem;
             margin-left: 0.5rem;
         }
          .tasks-list-header button i {
              margin-right: 4px;
          }

        .tasks-container {
            space-y: 0.8rem; /* Remplacé par marge */
        }
        .task-item {
            border: 1px solid rgba(255, 123, 0, 0.5);
            border-radius: 4px;
            padding: 0.8rem;
            background-color: rgba(0, 0, 0, 0.6);
            margin-bottom: 0.8rem; /* Remplace space-y */
        }
        .task-item:last-child {
             margin-bottom: 0;
        }
        .task-item-main {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }
        .task-item-details {
             display: flex;
             align-items: center;
             overflow: hidden; /* Empêche le débordement */
             flex-grow: 1; /* Prend l'espace dispo */
             margin-right: 1rem; /* Espace avant les actions/statut */
        }
        .task-icon {
             width: 30px;
             height: 30px;
             flex-shrink: 0;
             display: flex;
             align-items: center;
             justify-content: center;
             margin-right: 0.8rem;
        }
        .task-icon i {
             font-size: 1.1rem;
             color: #FF7B00; /* Couleur icône par défaut */
             opacity: 0.9;
        }
        .task-text {
            overflow: hidden; /* Pour ellipsis */
        }
        .task-title {
             font-weight: 500;
             font-size: 0.9rem;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             margin-bottom: 0.1rem;
        }
        .task-info, .task-error-info {
             font-size: 0.75rem;
             color: rgba(255, 123, 0, 0.7);
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
        }
        .task-error-info {
             color: #FF4136; /* Rouge pour erreurs */
        }
        .task-status-actions {
            display: flex;
            align-items: center;
            flex-shrink: 0; /* Ne réduit pas */
        }
        .task-status {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px; /* Pilule */
            margin-right: 0.7rem;
            white-space: nowrap;
            text-transform: capitalize;
             /* Couleurs spécifiques par statut */
             background-color: rgba(128, 128, 128, 0.5); color: rgba(255, 255, 255, 0.7); /* gris par défaut */
        }
        .task-status.completed { background-color: rgba(46, 204, 113, 0.5); color: #fff; }
        .task-status.failed, .task-status.canceled { background-color: rgba(255, 65, 54, 0.5); color: #fff; }
        .task-status.processing, .task-status.downloading { background-color: rgba(0, 116, 217, 0.5); color: #fff; }
        .task-status.queued { background-color: rgba(255, 193, 7, 0.5); color: #333; }

        .task-actions {
             display: flex;
             gap: 0.3rem;
        }
        .task-actions button {
             background: none;
             border: none;
             color: #FF7B00;
             opacity: 0.7;
             padding: 4px;
             cursor: pointer;
             font-size: 0.9rem;
        }
         .task-actions button:hover {
             opacity: 1;
             background: none; /* Pas de fond sur hover */
             box-shadow: none; /* Pas d'ombre sur hover */
         }
          .task-actions button.delete-btn:hover {
              color: red; /* Rouge pour supprimer */
          }

        .task-progress {
             margin-top: 0.6rem;
        }
        .progress-track {
             width: 100%;
             background-color: rgba(255, 123, 0, 0.2);
             border-radius: 5px;
             height: 6px; /* Plus fin */
             overflow: hidden;
        }
        .progress-bar {
             background-color: #FF7B00;
             height: 100%;
             border-radius: 5px;
             transition: width 0.3s ease;
        }
        .progress-text {
             text-align: right;
             font-size: 0.7rem;
             color: rgba(255, 123, 0, 0.7);
             margin-top: 0.2rem;
        }
        .empty-state { text-align: center; padding: 1.5rem; color: rgba(255, 123, 0, 0.6); }
        .empty-state-icon { font-size: 2rem; margin-bottom: 0.5rem; opacity: 0.5; }

        /* --- Style pour les Dropzones --- */
        .dropzone {
            border: 2px dashed rgba(255, 123, 0, 0.5);
            border-radius: 6px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s ease, background-color 0.2s ease;
            background-color: rgba(0, 0, 0, 0.3);
            margin-bottom: 1.5rem;
        }
        .dropzone:hover {
            border-color: #FF7B00;
            background-color: rgba(255, 123, 0, 0.05);
        }
        .dropzone i { /* Icône dans dropzone */
            font-size: 2.5rem;
            color: rgba(255, 123, 0, 0.6);
            margin-bottom: 0.8rem;
        }
        .dropzone h3 {
            font-weight: 500;
            font-size: 1.1rem;
            margin-bottom: 0.3rem;
        }
        .dropzone p {
            font-size: 0.8rem;
            color: rgba(255, 123, 0, 0.7);
            margin-bottom: 0.8rem;
        }
         .dropzone button {
             margin-top: 0.5rem;
         }
         .dropzone p.hint { /* Texte petit en bas */
              margin-top: 1rem;
              font-size: 0.75rem;
              opacity: 0.6;
         }

        /* --- Style spécifique Converter : Boutons de format --- */
         #converter-format-buttons-container {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); /* Responsive grid */
             gap: 0.5rem;
             margin-bottom: 1rem;
         }
         .format-btn {
             padding: 0.5rem;
             font-size: 0.8rem;
             text-align: center;
             background-color: rgba(255, 123, 0, 0.1);
             border: 1px solid rgba(255, 123, 0, 0.3);
             color: #FF7B00;
             border-radius: 3px;
             cursor: pointer;
             transition: all 0.2s ease;
         }
          .format-btn:hover {
              background-color: rgba(255, 123, 0, 0.2);
              border-color: #FF7B00;
          }
          .format-btn.selected { /* Style pour format sélectionné */
              background-color: #FF7B00;
              color: #000;
              border-color: #FF7B00;
              font-weight: 700;
              box-shadow: 0 0 8px rgba(255, 123, 0, 0.5);
          }

        /* --- Style spécifique Cropper --- */
        .cropper-container-wrapper { max-width: 100%; margin: auto; border: 1px dashed rgba(255,123,0,0.5); background: #000; }
        .img-container { width: 100%; max-height: 60vh; overflow: hidden; margin-bottom: 1rem; background-color: #111; } /* Fond sombre pour l'image */
        .img-container img { display: block; max-width: 100%; }
        /* Styles CropperJS - Les couleurs peuvent être ajustées si besoin */
        .cropper-view-box, .cropper-face { border-radius: 0; outline: 1px solid #FF7B00; } /* Style rétro */
        .cropper-line { background-color: rgba(255, 123, 0, 0.5); }
        .cropper-point { background-color: #FF7B00; opacity: 0.8; }

        /* --- Style spécifique Square Center --- */
         #square-preview-wrapper { width: 100%; max-width: 450px; margin: 1rem auto; }
         #square-preview-container { width: 100%; border: 1px dashed rgba(255, 123, 0, 0.5); background-color: rgba(0,0,0,0.3); position: relative; overflow: hidden; }
         #square-preview-canvas { display: block; width: 100%; height: 100%; object-fit: contain; }
         .square-options-box {
             margin-bottom: 1.5rem;
             padding: 1rem;
             border: 1px solid rgba(255, 123, 0, 0.5);
             border-radius: 4px;
             background-color: rgba(0, 0, 0, 0.5);
         }
          .square-options-box h4 {
             text-align: center;
             font-size: 1.1rem;
             font-weight: 600;
             margin-bottom: 1rem;
             border-bottom: 1px solid rgba(255, 123, 0, 0.3);
             padding-bottom: 0.5rem;
          }
           .square-options-grid {
              display: grid;
              grid-template-columns: 1fr; /* 1 colonne par défaut */
              gap: 1rem;
           }
           @media (min-width: 640px) { /* 2 colonnes sur écrans plus grands */
               .square-options-grid { grid-template-columns: 1fr 1fr; }
           }
           .square-option-group label.block { /* Label principal du groupe */
               font-weight: 500;
               margin-bottom: 0.5rem;
               font-size: 0.9rem;
           }
           .radio-label { /* Style pour les labels des boutons radio */
               display: flex;
               align-items: center;
               cursor: pointer;
               font-size: 0.9rem;
               margin-bottom: 0.5rem;
               color: rgba(255, 123, 0, 0.9);
           }
            .radio-label input[type="radio"] {
                margin-right: 0.5rem;
                accent-color: #FF7B00; /* Couleur de la coche */
                cursor: pointer;
            }
            #color-swatch-container {
                display: flex;
                flex-wrap: wrap;
                gap: 8px; /* Espace entre les couleurs */
                margin-top: 0.3rem;
            }
            .color-swatch {
                width: 24px; /* Taille réduite */
                height: 24px;
                border-radius: 50%;
                cursor: pointer;
                border: 2px solid transparent;
                transition: transform 0.1s ease, border-color 0.1s ease, box-shadow 0.1s ease;
                box-shadow: 0 0 0 1px rgba(255, 123, 0, 0.3); /* Bordure légère */
            }
            .color-swatch:hover { transform: scale(1.1); }
            .color-swatch.selected {
                border-color: #FF7B00;
                transform: scale(1.1);
                box-shadow: 0 0 0 2px #FF7B00;
            }

        /* --- Style pour Toasts et Modals --- */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 4px;
            background-color: #FF7B00; /* Orange par défaut */
            color: #000; /* Texte noir pour contraste */
            box-shadow: 0 0 15px rgba(255, 123, 0, 0.5);
            transform: translateY(120px); /* Encore plus bas initialement */
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* Effet rebond */
            z-index: 1050;
            max-width: 90%;
            font-size: 0.9rem;
        }
        @media (min-width: 640px) {
            .toast { max-width: 350px; }
        }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.success { background-color: #2ECC40; color: #fff; } /* Vert */
        .toast.error { background-color: #FF4136; color: #fff; } /* Rouge */
        .toast.info { background-color: #0074D9; color: #fff; } /* Bleu */

        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8); /* Plus sombre */
            display: flex; align-items: center; justify-content: center;
            z-index: 1040; opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
        }
        .modal-overlay.show { opacity: 1; pointer-events: auto; }
        .modal-content {
            background-color: #111; /* Fond très sombre */
            padding: 1.5rem;
            border-radius: 4px;
            border: 1px solid #FF7B00;
            box-shadow: 0 0 25px rgba(255, 123, 0, 0.4);
            max-width: 90%;
            width: 400px;
            color: #FF7B00; /* Texte orange par défaut */
            transform: scale(0.95) translateY(10px); /* Effet d'apparition */
            transition: transform 0.2s ease-in-out;
        }
        .modal-overlay.show .modal-content { transform: scale(1) translateY(0); }
         .modal-content h3 { /* Titre modal */
             font-size: 1.2rem;
             font-weight: 600;
             margin-bottom: 0.8rem;
             text-shadow: 0 0 5px #FF7B00;
         }
         .modal-content p { /* Message modal */
             font-size: 0.9rem;
             color: rgba(255, 123, 0, 0.9);
             margin-bottom: 1.5rem;
         }
         .modal-actions {
             display: flex;
             justify-content: flex-end; /* Boutons à droite */
             gap: 0.8rem;
         }
          /* Style spécifique pour les boutons de la modale */
         #modal-cancel-btn {
             background-color: rgba(80, 80, 80, 0.7); /* Gris */
             border-color: rgba(255, 123, 0, 0.5);
             color: rgba(255, 123, 0, 0.8);
         }
          #modal-cancel-btn:hover {
             background-color: rgba(100, 100, 100, 0.7);
             border-color: #FF7B00;
             color: #FF7B00;
          }
          #modal-confirm-btn {
             background-color: rgba(200, 50, 50, 0.7); /* Rouge sombre */
             border-color: rgba(255, 65, 54, 0.8);
             color: #fff;
          }
           #modal-confirm-btn:hover {
             background-color: rgba(255, 65, 54, 0.8); /* Rouge plus vif */
             border-color: #FF4136;
             box-shadow: 0 0 10px rgba(255, 65, 54, 0.5);
           }

        /* --- Media Queries de Gadget Lab (Adaptées) --- */
        @media (max-width: 768px) {
          h1 { font-size: 2.5rem; }
          h2 { font-size: 1.5rem; letter-spacing: 4px; }
          .divergence-meter { font-size: 0.9rem; padding: 0.5rem; }
          .header { margin-top: 1.5rem; padding: 1.5rem 1rem; }
          .tab-btn { padding: 10px 8px; font-size: 0.8rem; }
          .tab-content { padding: 1rem; }
          input[type="url"], input[type="text"], select, button, .button-style { font-size: 0.85rem; padding: 0.5rem 0.8rem; }
          .tasks-list-header h3 { font-size: 1rem; }
          .tasks-list-header button { padding: 0.2rem 0.5rem; font-size: 0.75rem; }
          .task-item { padding: 0.6rem; }
          .task-title { font-size: 0.85rem; }
          .task-info, .task-error-info, .progress-text { font-size: 0.7rem; }
          .task-status { font-size: 0.65rem; padding: 2px 5px; margin-right: 0.5rem; }
          .task-actions button { font-size: 0.8rem; }
          .dropzone { padding: 1.5rem; }
          .dropzone i { font-size: 2rem; }
          .dropzone h3 { font-size: 1rem; }
          .dropzone p { font-size: 0.75rem; }
        }
        @media (max-width: 480px) {
          h1 { font-size: 2rem; }
          h2 { font-size: 1.2rem; letter-spacing: 3px; }
          .divergence-meter { font-size: 0.75rem; padding: 0.4rem; }
          .header { padding: 1rem; margin-top: 1rem; }
          .tab-btn { font-size: 0.7rem; padding: 8px 5px; }
          .tab-btn i { margin-right: 3px; }
          .url-input-container { flex-direction: column; } /* Input et bouton l'un sous l'autre */
          .url-input-container input[type="url"] { border-radius: 3px 3px 0 0; border-right: 1px solid #FF7B00; }
          .url-input-container button { border-radius: 0 0 3px 3px; width: 100%; }
          .footer { padding-bottom: 1rem; } /* Moins de padding en bas sur mobile */
          .small { font-size: 0.7rem; }
           #video-thumbnail { width: 80px; height: 60px; margin-right: 0.8rem;}
           .info-box h3 { font-size: 0.9rem;}
           .info-box p { font-size: 0.7rem;}
        }
    </style>
</head>
<body>
    <!-- Gestionnaire d'arrière-plan -->
    <div class="background-container">
      <div class="background-image"></div>
    </div>

    <!-- Effets VCR -->
    <div class="vcr-overlay">
      <div class="scanlines"></div>
      <div class="noise"></div>
      <div class="vignette"></div>
    </div>

    <!-- Header style Gadget Lab -->
    <header class="header">
      <div class="logo-container">
        <!-- Adaptez les textes ici -->
        <h1>メディアハブ</h1>
        <h2>MEDIA HUB</h2>
        <div class="divergence-meter">PROCESSING MEDIA // 1.048596</div>
      </div>
    </header>

    <!-- Contenu principal du Media Hub -->
    <div class="main-content-wrapper">
        <div class="content-box">
            <!-- Onglets -->
            <div class="tab-container">
                <button class="tab-btn" data-tab="youtube"><i class="fab fa-youtube"></i> YouTube</button>
                <button class="tab-btn" data-tab="converter"><i class="fas fa-exchange-alt"></i> Converter</button>
                <button class="tab-btn" data-tab="cropper"><i class="fas fa-crop-alt"></i> Cropper</button>
                <button class="tab-btn" data-tab="square-center"><i class="fas fa-expand-arrows-alt"></i> Aspect Fit</button>
            </div>

            <!-- Contenu YouTube -->
            <div id="youtube-content" class="tab-content">
                <div class="url-input-container">
                    <input type="url" id="youtube-url" placeholder="https://www.youtube.com/watch?v=..." aria-label="YouTube URL">
                    <button id="fetch-info" class="glitch-element" data-text="Fetch Info">
                        <span class="button-text">Fetch Info</span>
                        <i class="fas fa-spinner fa-spin ml-2 hidden"></i>
                    </button>
                </div>
                <div id="video-info" class="info-box hidden">
                    <div id="video-thumbnail"></div>
                    <div>
                        <h3 id="video-title"></h3>
                        <p id="video-duration"></p>
                    </div>
                </div>
                <div id="download-options" class="hidden">
                    <div style="margin-bottom: 1rem;">
                        <label for="quality">Format</label>
                        <select id="quality">
                            <option value="video_best">Video - Best Quality</option>
                            <option value="video_1080p">Video - 1080p (HD)</option>
                            <option value="video_720p">Video - 720p (HD)</option>
                            <option value="video_480p">Video - 480p (SD)</option>
                            <option value="video_360p">Video - 360p (Low)</option>
                            <option value="audio_mp3">Audio - MP3</option>
                        </select>
                    </div>
                    <button id="start-download" style="width: 100%;" class="glitch-element" data-text="Download">
                        <span class="button-text">Download</span>
                        <i class="fas fa-spinner fa-spin ml-2 hidden"></i>
                    </button>
                </div>
                <div id="downloads-list" style="margin-top: 2rem;">
                    <div class="tasks-list-header">
                        <h3><i class="fas fa-history"></i> Downloads</h3>
                        <div>
                            <button type="button" id="refresh-downloads" title="Refresh List"><i class="fas fa-sync-alt"></i><span class="hidden sm:inline ml-1"> Refresh</span></button>
                            <button type="button" id="clear-downloads" title="Clear All Downloads"><i class="fas fa-trash"></i><span class="hidden sm:inline ml-1"> Clear All</span></button>
                        </div>
                    </div>
                    <div id="downloads-container" class="tasks-container">
                        <div class="empty-state"><div class="empty-state-icon"><i class="fas fa-download"></i></div><p>No downloads yet</p></div>
                    </div>
                </div>
            </div>

            <!-- Contenu Converter -->
            <div id="converter-content" class="tab-content hidden">
                 <div> <!-- Wrapper pour max-width -->
                     <div class="dropzone" id="converter-dropzone">
                        <input type="file" id="converter-file-input" class="hidden" accept="image/*,video/*,audio/*,.pdf,.txt,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.odt,.ods,.odp">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <h3>Drag & Drop File</h3>
                        <p>or</p>
                        <button type="button" id="converter-browse-files" class="glitch-element" data-text="Browse">Browse</button>
                        <p class="hint">Max: 500MB. Images, Audio, Video, Docs.</p>
                    </div>
                    <div id="converter-file-info" class="info-box hidden">
                         <div style="display: flex; align-items: center; overflow: hidden; margin-right: 1rem;">
                            <i id="converter-file-info-icon" class="fas fa-file"></i>
                            <div class="task-text"> <!-- Utilise task-text pour ellipsis -->
                                <h3 id="converter-file-name"></h3>
                                <p id="converter-file-size"></p>
                                <p id="converter-file-type-info" style="font-size: 0.7rem; opacity: 0.6;"></p>
                            </div>
                        </div>
                         <button type="button" id="converter-remove-file" title="Remove file">
                             <i class="fas fa-times-circle fa-lg"></i>
                         </button>
                    </div>
                    <div id="converter-conversion-options" class="hidden">
                        <div style="margin-bottom: 1rem;">
                            <label>Convert to</label>
                             <p id="converter-no-formats-message" class="hidden" style="color: #FF4136; font-size: 0.8rem; margin-bottom: 1rem;">No compatible conversion formats found.</p>
                            <div id="converter-format-buttons-container">
                                <!-- Les boutons sont générés par JS mais voici des exemples stylisés -->
                                <button type="button" class="format-btn hidden" data-format="mp4">MP4</button>
                                <button type="button" class="format-btn hidden" data-format="mp3">MP3</button>
                                <button type="button" class="format-btn hidden" data-format="jpg">JPG</button>
                                <!-- ... autres formats ... -->
                            </div>
                        </div>
                        <button type="button" id="start-conversion" style="width: 100%;" class="glitch-element" data-text="Convert File" disabled>
                             <span class="button-text">Convert File</span>
                             <i class="fas fa-spinner fa-spin ml-2 hidden"></i>
                        </button>
                    </div>
                    <div id="conversions-list" style="margin-top: 2rem;">
                        <div class="tasks-list-header">
                             <h3><i class="fas fa-history"></i> Conversions</h3>
                            <div>
                                <button type="button" id="refresh-conversions" title="Refresh List"><i class="fas fa-sync-alt"></i><span class="hidden sm:inline ml-1"> Refresh</span></button>
                                <button type="button" id="clear-conversions" title="Clear All Conversions"><i class="fas fa-trash"></i><span class="hidden sm:inline ml-1"> Clear All</span></button>
                            </div>
                        </div>
                        <div id="conversions-container" class="tasks-container">
                            <div class="empty-state"><div class="empty-state-icon"><i class="fas fa-exchange-alt"></i></div><p>No conversions yet</p></div>
                        </div>
                    </div>
                 </div>
            </div>

            <!-- Contenu Cropper -->
            <div id="cropper-content" class="tab-content hidden">
                 <div> <!-- Wrapper pour max-width -->
                     <div id="cropper-upload-section">
                        <div class="dropzone" id="cropper-dropzone">
                            <input type="file" id="cropper-file-input" class="hidden" accept="image/png, image/jpeg, image/webp, image/gif, image/bmp">
                            <i class="fas fa-image"></i>
                            <h3>Drag & Drop Image</h3>
                            <p>or</p>
                            <button type="button" id="cropper-browse-files" class="glitch-element" data-text="Browse">Browse</button>
                            <p class="hint">PNG, JPG, WEBP, GIF, BMP. Max 50MB.</p>
                        </div>
                    </div>
                    <div id="cropper-main-section" class="hidden">
                        <div class="cropper-container-wrapper mb-4">
                             <div class="img-container">
                                <img id="cropper-image" src="#" alt="Image to crop">
                             </div>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem; margin-bottom: 1rem;">
                             <button type="button" id="crop-btn" class="glitch-element" data-text="Crop & DL">
                                <i class="fas fa-check" style="margin-right: 8px;"></i>Crop & DL
                            </button>
                             <button type="button" id="cropper-reset-btn">
                                <i class="fas fa-sync-alt" style="margin-right: 8px;"></i>Reset
                            </button>
                            <button type="button" id="cropper-change-image-btn" style="background-color: rgba(200, 50, 50, 0.7);">
                                <i class="fas fa-times" style="margin-right: 8px;"></i>Change
                            </button>
                        </div>
                    </div>
                 </div>
            </div>

            <!-- Contenu Square Center -->
             <div id="square-center-content" class="tab-content hidden">
                 <div> <!-- Wrapper -->
                     <div id="square-upload-section">
                        <div class="dropzone" id="square-dropzone">
                            <input type="file" id="square-file-input" class="hidden" accept="image/png, image/jpeg, image/webp">
                            <i class="fas fa-expand-arrows-alt"></i>
                            <h3>Drag & Drop Image</h3>
                            <p>or</p>
                            <button type="button" id="square-browse-files" class="glitch-element" data-text="Browse">Browse</button>
                            <p class="hint">PNG, JPG, WEBP. Max 50MB.</p>
                        </div>
                    </div>
                    <div id="square-main-section" class="hidden">
                         <div id="square-preview-wrapper">
                             <div id="square-preview-container">
                                <canvas id="square-preview-canvas"></canvas>
                             </div>
                         </div>
                         <img id="square-source-image" src="#" alt="Source Image" class="hidden"> <!-- Source pour canvas -->

                         <div class="square-options-box">
                            <h4>Options</h4>
                            <div class="square-options-grid">
                                <div>
                                    <label for="square-aspect-ratio" class="block">Aspect Ratio</label>
                                    <select id="square-aspect-ratio"></select>
                                </div>
                                <div>
                                    <label class="block">Background</label>
                                    <div>
                                        <label class="radio-label">
                                            <input type="radio" name="square-bg-option" value="border" checked>
                                            <span>Use Border Color</span>
                                        </label>
                                        <div style="display: flex; align-items: flex-start;">
                                            <label class="radio-label" style="margin-right: 10px; margin-top: 4px;">
                                                <input type="radio" name="square-bg-option" value="custom">
                                                <span>Custom:</span>
                                            </label>
                                            <div id="color-swatch-container"></div>
                                        </div>
                                     </div>
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem;">
                            <button type="button" id="square-process-btn" class="glitch-element" data-text="Process & DL">
                                <i class="fas fa-check" style="margin-right: 8px;"></i>Process & DL
                            </button>
                             <button type="button" id="square-change-image-btn" style="background-color: rgba(200, 50, 50, 0.7);">
                                <i class="fas fa-times" style="margin-right: 8px;"></i>Change
                            </button>
                        </div>
                    </div>
                 </div>
            </div>
        </div> <!-- Fin content-box -->
    </div> <!-- Fin main-content-wrapper -->

    <!-- Footer style Gadget Lab -->
    <footer class="footer">
      <div class="footer-text">
        <p>© <span id="current-year">2023</span> メディアハブ // MEDIA HUB PROJECT</p>
        <p class="small blink">El Psy Kongroo</p>
      </div>
    </footer>

    <!-- Template pour les tâches (conservé pour JS) -->
    <template id="task-template">
        <div class="task-item">
            <div class="task-item-main">
                <div class="task-item-details">
                    <div class="task-icon">
                        <i class="fas fa-file-video"></i> <!-- Icône par défaut -->
                    </div>
                    <div class="task-text">
                        <h4 class="task-title"></h4>
                        <p class="task-info"></p>
                         <p class="task-error-info hidden"></p>
                    </div>
                </div>
                <div class="task-status-actions">
                    <div class="task-status"></div>
                    <div class="task-actions"></div>
                </div>
            </div>
            <div class="task-progress hidden">
                <div class="progress-track">
                    <div class="progress-bar" style="width: 0%"></div>
                </div>
                <p class="progress-text">0%</p>
            </div>
        </div>
    </template>

    <!-- Toast (conservé pour JS) -->
    <div id="toast" class="toast"><div id="toast-message"></div></div>

    <!-- Modal de Confirmation (conservé pour JS) -->
    <div id="confirmation-modal" class="modal-overlay hidden" aria-labelledby="modal-title" role="dialog" aria-modal="true">
        <div class="modal-content">
            <h3 id="modal-title">Confirmation</h3>
            <div>
                <p id="modal-message">Are you sure?</p>
            </div>
            <div class="modal-actions">
                <button id="modal-cancel-btn" type="button">Cancel</button>
                <button id="modal-confirm-btn" type="button">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Scripts (Conservés) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script>
        // --- Fonction Glitch Aléatoire (ajoutée depuis Gadget Lab) ---
        function randomGlitch() {
          const glitchElements = document.querySelectorAll('.glitch-element');

          if (glitchElements.length && Math.random() > 0.85) { // Augmenté la fréquence un peu
            const randomElement = glitchElements[Math.floor(Math.random() * glitchElements.length)];

            // Ajouter data-text si pas déjà présent (pour les pseudo-éléments)
            if (!randomElement.dataset.text) {
                const textContent = randomElement.querySelector('.button-text')?.textContent || randomElement.textContent.trim();
                if (textContent) {
                   randomElement.dataset.text = textContent;
                }
            }

            randomElement.classList.add('active');

            setTimeout(() => {
              randomElement.classList.remove('active');
            }, 150 + Math.random() * 300); // Durée plus courte
          }
        }
        let glitchInterval = setInterval(randomGlitch, 3000); // Vérifie toutes les 3 secondes

        // --- TOUT LE JAVASCRIPT ORIGINAL DU MEDIA HUB EST ICI ---
        // (J'ai gardé exactement le même code JS que vous avez fourni)
        // Il faudra peut-être ajuster quelques sélecteurs si le HTML a trop changé
        // ou si des classes utilitaires comme 'hidden' ont été modifiées.

        const apiBaseUrl = 'http://localhost:8000'; // Needs to match your backend address
        const USER_DOWNLOADS_KEY = 'user_downloads';
        const USER_CONVERSIONS_KEY = 'user_conversions';
        const MAX_FILE_SIZE_MB = 500;
        const MAX_IMAGE_SIZE_MB = 50;
        const POLL_INTERVAL_MS = 5000;
        const modalElement = document.getElementById('confirmation-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        let confirmCallback = null;
        function showModal(message, onConfirm) {
            modalMessage.textContent = message; confirmCallback = onConfirm;
            modalElement.classList.remove('hidden');
            requestAnimationFrame(() => modalElement.classList.add('show'));
        }
        function hideModal() {
            modalElement.classList.remove('show');
            setTimeout(() => { modalElement.classList.add('hidden'); confirmCallback = null; }, 200);
        }
        modalConfirmBtn.addEventListener('click', () => { if (typeof confirmCallback === 'function') confirmCallback(); hideModal(); });
        modalCancelBtn.addEventListener('click', hideModal);
        modalElement.addEventListener('click', (e) => { if (e.target === modalElement) hideModal(); });
        function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { const r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8; return v.toString(16); }); }
        function formatFileSize(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024, i = Math.floor(Math.log(bytes) / Math.log(k)); return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${['Bytes', 'KB', 'MB', 'GB'][i]}`; }
        function formatDuration(seconds) { if (seconds == null || isNaN(seconds)) return 'Unknown duration'; seconds = Math.round(seconds); const hrs = Math.floor(seconds / 3600), mins = Math.floor(seconds % 3600 / 60), secs = seconds % 60; return (hrs > 0 ? `${hrs}:` : '') + `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`; }
        if (!sessionStorage.getItem('user_id')) sessionStorage.setItem('user_id', generateUUID());
        function getStorageKey(type) { return type === 'download' ? USER_DOWNLOADS_KEY : USER_CONVERSIONS_KEY; }
        function getTaskIdField(type) { return type === 'download' ? 'download_id' : 'conversion_id'; }
        function saveUserTask(type, data) { const k = getStorageKey(type), idField = getTaskIdField(type); let ts = JSON.parse(sessionStorage.getItem(k) || '[]'); const id = data[idField]; const i = ts.findIndex(t => t[idField] === id); if (i >= 0) ts[i] = { ...ts[i], ...data }; else ts.push(data); sessionStorage.setItem(k, JSON.stringify(ts)); }
        function getUserTasks(type) { return JSON.parse(sessionStorage.getItem(getStorageKey(type)) || '[]'); }
        function deleteUserTask(type, id) { const k = getStorageKey(type), idField = getTaskIdField(type); let ts = getUserTasks(type); ts = ts.filter(t => t[idField] !== id); sessionStorage.setItem(k, JSON.stringify(ts)); }
        function clearUserTasks(type) { sessionStorage.setItem(getStorageKey(type), '[]'); const endpoint = type === 'download' ? `${apiBaseUrl}/youtube/clear-all` : `${apiBaseUrl}/conversion/clear-all`; fetch(endpoint, { method: 'DELETE' }).catch(e => console.warn(`Failed server clear ${type}`, e)); }
        function showToast(message, type = 'info', duration = 4000) { const t = document.getElementById('toast'), m = document.getElementById('toast-message'); m.textContent = message; t.className = `toast ${type}`; setTimeout(() => t.classList.add('show'), 10); setTimeout(() => { t.classList.remove('show'); /* Reset class after hiding */ setTimeout(() => t.className = 'toast', 400); }, duration); }
        function setActiveTab(tabId) {
            const activeTab = document.querySelector(`.tab-btn[data-tab="${tabId}"]`); 
            if (!activeTab) return;
            
            // Retirer toutes les classes active de tous les onglets
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            
            // Activer l'onglet sélectionné
            activeTab.classList.add('active');
            
            // Cacher tous les contenus d'onglets
            document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
            
            // Afficher le contenu de l'onglet sélectionné (sans animation)
            const contentEl = document.getElementById(tabId + '-content'); 
            if (contentEl) contentEl.classList.remove('hidden');
            
            // Mettre à jour l'URL (si nécessaire)
            const url = new URL(window.location);
            url.searchParams.set('tab', tabId); 
            window.history.pushState({}, '', url);
        }
        function initializeTabFromUrl() { const params = new URLSearchParams(window.location.search), tab = params.get('tab'), validTabs = ['youtube', 'converter', 'cropper', 'square-center']; setActiveTab(tab && validTabs.includes(tab) ? tab : 'youtube'); }
        document.querySelectorAll('.tab-btn').forEach(b => b.addEventListener('click', () => setActiveTab(b.dataset.tab)));
        function setLoadingState(btn, isLoading, defaultText = 'Submit') {
            const txtEl = btn.querySelector('.button-text');
            const iconEl = btn.querySelector('.fa-spinner');
            const currentText = txtEl ? txtEl.textContent : btn.textContent.trim();

            // Store default text if not already stored
            if (!btn.dataset.defaultText && !isLoading) {
                btn.dataset.defaultText = currentText;
            }
            const effectiveDefaultText = btn.dataset.defaultText || defaultText;

            btn.disabled = isLoading;
            if (txtEl) {
                txtEl.textContent = isLoading ? '処理中...' : effectiveDefaultText; // Using Japanese for processing
            } else {
                 btn.firstChild.nodeValue = isLoading ? '処理中... ' : effectiveDefaultText + ' '; // Add space for icon if needed
            }
            if (iconEl) {
                 iconEl.classList.toggle('hidden', !isLoading);
            }

            // Clear default text when done loading
             if (!isLoading) {
                 delete btn.dataset.defaultText;
             }
        }
        async function handleApiError(response, defaultMessage) { let msg = defaultMessage; try { const data = await response.json(); msg = data.detail || data.message || `${response.status}: ${response.statusText || 'API Error'}`; } catch (e) { msg = `${response.status}: ${response.statusText || 'Request failed'}`; } console.error("API Error:", msg, response); return msg; }
        const fetchInfoButton = document.getElementById('fetch-info');
        const videoUrlInput = document.getElementById('youtube-url');
        const videoInfoDiv = document.getElementById('video-info');
        const videoThumbnailDiv = document.getElementById('video-thumbnail');
        const videoTitleEl = document.getElementById('video-title');
        const videoDurationEl = document.getElementById('video-duration');
        const downloadOptionsDiv = document.getElementById('download-options');
        fetchInfoButton.addEventListener('click', async () => {
            const url = videoUrlInput.value.trim(); if (!url || (!url.includes('youtube.com') && !url.includes('youtu.be'))) return showToast('有効なYouTube URLを入力してください', 'error'); setLoadingState(fetchInfoButton, true); videoInfoDiv.classList.add('hidden'); downloadOptionsDiv.classList.add('hidden');
            try {
                const response = await fetch(`${apiBaseUrl}/info?url=${encodeURIComponent(url)}`); if (!response.ok) throw new Error(await handleApiError(response, 'ビデオ情報の取得に失敗しました')); const data = await response.json(); videoTitleEl.textContent = data.title || '不明なタイトル'; videoDurationEl.textContent = formatDuration(data.duration); videoThumbnailDiv.style.backgroundImage = data.thumbnail ? `url(${data.thumbnail})` : ''; videoThumbnailDiv.style.backgroundColor = data.thumbnail ? 'transparent' : 'rgba(255, 123, 0, 0.1)'; videoInfoDiv.classList.remove('hidden'); downloadOptionsDiv.classList.remove('hidden'); showToast('ビデオ情報をロードしました！', 'success');
            } catch (e) { console.error(e); showToast(e.message, 'error'); } finally { setLoadingState(fetchInfoButton, false); }
        });
        const startDownloadButton = document.getElementById('start-download');
        const qualitySelect = document.getElementById('quality');
        startDownloadButton.addEventListener('click', async () => {
            const url = videoUrlInput.value.trim(); if (!url) return showToast('YouTube URLがありません', 'error'); const qualityOption = qualitySelect.value; let quality = 'best', mode = 'video+audio'; if (qualityOption.startsWith('video_')) quality = qualityOption.replace('video_', ''); else if (qualityOption === 'audio_mp3') mode = 'audio-only'; setLoadingState(startDownloadButton, true);
            try {
                const response = await fetch(`${apiBaseUrl}/youtube`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url, quality, mode }) }); if (!response.ok) throw new Error(await handleApiError(response, 'ダウンロードタスクの開始に失敗しました')); saveUserTask('download', await response.json()); showToast('ダウンロードタスクを開始しました！', 'success'); displayUserDownloads();
            } catch (e) { console.error(e); showToast(e.message, 'error'); } finally { setLoadingState(startDownloadButton, false); }
        });
        const converterDropzone = document.getElementById('converter-dropzone'), converterFileInput = document.getElementById('converter-file-input'), converterFileInfoDiv = document.getElementById('converter-file-info'), converterConversionOptionsDiv = document.getElementById('converter-conversion-options'), startConversionButton = document.getElementById('start-conversion'), converterRemoveFileButton = document.getElementById('converter-remove-file');
        const converterFileInfoIcon = document.getElementById('converter-file-info-icon'), converterFileNameEl = document.getElementById('converter-file-name'), converterFileSizeEl = document.getElementById('converter-file-size'), converterFileTypeInfoEl = document.getElementById('converter-file-type-info');
        const converterFormatButtonsContainer = document.getElementById('converter-format-buttons-container'), converterNoFormatsMsg = document.getElementById('converter-no-formats-message');
        let converterSelectedFile = null, converterSelectedFormat = null;
        const conversionMap = { image: ['jpg', 'png', 'gif', 'webp', 'pdf', 'bmp', 'tiff'], audio: ['mp3', 'wav', 'aac', 'ogg', 'flac', 'm4a'], video: ['mp4', 'webm', 'gif', 'mp3', 'mov', 'avi', 'mkv'], document: ['pdf', 'txt', 'html', 'docx', 'odt'], spreadsheet: ['xlsx', 'ods', 'csv'], presentation: ['pptx', 'odp', 'pdf'] };
        const mimeCategoryMap = { 'image': 'image', 'audio': 'audio', 'video': 'video', 'application/pdf': 'document', 'text/plain': 'document', 'msword': 'document', 'officedocument.wordprocessingml': 'document', 'ms-excel': 'spreadsheet', 'officedocument.spreadsheetml': 'spreadsheet', 'ms-powerpoint': 'presentation', 'officedocument.presentationml': 'presentation', 'opendocument.text': 'document', 'opendocument.spreadsheet': 'spreadsheet', 'opendocument.presentation': 'presentation' };
        const extCategoryMap = { jpg: 'image', jpeg: 'image', png: 'image', gif: 'image', webp: 'image', bmp: 'image', tiff: 'image', svg: 'image', mp3: 'audio', wav: 'audio', ogg: 'audio', aac: 'audio', flac: 'audio', m4a: 'audio', mp4: 'video', webm: 'video', mov: 'video', avi: 'video', mkv: 'video', wmv: 'video', flv: 'video', pdf: 'document', txt: 'document', doc: 'document', docx: 'document', rtf: 'document', odt: 'document', html: 'document', htm: 'document', xls: 'spreadsheet', xlsx: 'spreadsheet', csv: 'spreadsheet', ods: 'spreadsheet', ppt: 'presentation', pptx: 'presentation', odp: 'presentation' };
        const categoryIcons = { image: 'fa-file-image', audio: 'fa-file-audio', video: 'fa-file-video', document: 'fa-file-alt', spreadsheet: 'fa-file-excel', presentation: 'fa-file-powerpoint' };
        function getFileCategory(file) { if (!file) return null; const mime = file.type, ext = file.name.split('.').pop().toLowerCase(); const mimeBase = mime.split('/')[0]; if (mimeCategoryMap[mime]) return mimeCategoryMap[mime]; if (mimeCategoryMap[mimeBase]) return mimeCategoryMap[mimeBase]; for (const key in mimeCategoryMap) { if (mime.includes(key)) return mimeCategoryMap[key]; } return extCategoryMap[ext] || null; }
        function updateConverterUI() {
            if (converterSelectedFile) {
                const category = getFileCategory(converterSelectedFile), possibleFormats = category ? (conversionMap[category] || []) : [], currentExt = converterSelectedFile.name.split('.').pop().toLowerCase();
                converterFileInfoIcon.className = `fas ${categoryIcons[category] || 'fa-file'}`; // Update class directly
                converterFileNameEl.textContent = converterSelectedFile.name; converterFileSizeEl.textContent = formatFileSize(converterSelectedFile.size); converterFileTypeInfoEl.textContent = `タイプ: ${converterSelectedFile.type || '不明'} (${category || '不明'})`; // Japanese type/unknown
                converterFileInfoDiv.classList.remove('hidden'); converterConversionOptionsDiv.classList.remove('hidden');
                let visibleCount = 0;
                converterFormatButtonsContainer.querySelectorAll('.format-btn').forEach(btn => {
                    const format = btn.dataset.format, isPossible = possibleFormats.includes(format) && format !== currentExt;
                    btn.classList.toggle('hidden', !isPossible);
                    if (isPossible) visibleCount++;
                    // Reset style if it was selected but now hidden/impossible
                    else if (btn.classList.contains('selected')) { btn.classList.remove('selected'); converterSelectedFormat = null; }
                });
                converterNoFormatsMsg.classList.toggle('hidden', visibleCount > 0);
                if (visibleCount === 0) converterSelectedFormat = null;
            } else {
                converterFileInfoDiv.classList.add('hidden'); converterConversionOptionsDiv.classList.add('hidden'); converterFormatButtonsContainer.querySelectorAll('.format-btn').forEach(b => b.classList.add('hidden')); converterNoFormatsMsg.classList.add('hidden'); converterSelectedFormat = null;
            }
            startConversionButton.disabled = !(converterSelectedFile && converterSelectedFormat);
        }
        function handleConverterFileSelection(file) { if (!file) return resetConverterSelection(); const maxSize = MAX_FILE_SIZE_MB * 1024 * 1024; if (file.size > maxSize) { showToast(`ファイルが ${MAX_FILE_SIZE_MB}MB の制限を超えています`, 'error'); return resetConverterSelection(); } converterSelectedFile = file; updateConverterUI(); showToast('ファイルを選択しました。変換形式を選択してください。', 'info'); }
        function resetConverterSelection() { converterSelectedFile = null; converterSelectedFormat = null; converterFileInput.value = ''; updateConverterUI(); converterFormatButtonsContainer.querySelectorAll('.format-btn.selected').forEach(b => { b.classList.remove('selected'); }); }
        converterDropzone.addEventListener('dragover', (e) => { e.preventDefault(); converterDropzone.classList.add('hover'); }); // Simple hover class
        converterDropzone.addEventListener('dragleave', () => converterDropzone.classList.remove('hover'));
        converterDropzone.addEventListener('drop', (e) => { e.preventDefault(); converterDropzone.classList.remove('hover'); if (e.dataTransfer.files?.[0]) handleConverterFileSelection(e.dataTransfer.files[0]); });
        document.getElementById('converter-browse-files').addEventListener('click', () => converterFileInput.click()); converterFileInput.addEventListener('change', (e) => handleConverterFileSelection(e.target.files?.[0])); converterRemoveFileButton.addEventListener('click', resetConverterSelection);
        converterFormatButtonsContainer.querySelectorAll('.format-btn').forEach(btn => { btn.addEventListener('click', () => { if (btn.classList.contains('hidden')) return; converterFormatButtonsContainer.querySelectorAll('.format-btn').forEach(b => { b.classList.remove('selected'); }); btn.classList.add('selected'); converterSelectedFormat = btn.dataset.format; startConversionButton.disabled = false; showToast(`選択形式: ${converterSelectedFormat.toUpperCase()}`, 'info', 2000); }); });
        startConversionButton.addEventListener('click', async () => {
            if (!converterSelectedFile || !converterSelectedFormat) return; setLoadingState(startConversionButton, true); // Default text is handled by setLoadingState
            try {
                setLoadingState(startConversionButton, true, 'アップロード中...'); // Override default text
                const formData = new FormData(); formData.append('file', converterSelectedFile); formData.append('title', converterSelectedFile.name); const uploadResponse = await fetch(`${apiBaseUrl}/uploads/upload`, { method: 'POST', body: formData }); if (!uploadResponse.ok) throw new Error(`アップロードエラー: ${await handleApiError(uploadResponse, 'ファイルアップロード失敗')}`); const uploadResult = await uploadResponse.json(); showToast('アップロード完了。変換を開始します...', 'info');
                setLoadingState(startConversionButton, true, '変換中...'); // Override default text
                const convertResponse = await fetch(`${apiBaseUrl}/conversion/convert`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ download_id: uploadResult.download_id, output_format: converterSelectedFormat }) }); if (!convertResponse.ok) throw new Error(`変換エラー: ${await handleApiError(convertResponse, '変換タスク開始失敗')}`); saveUserTask('conversion', await convertResponse.json()); showToast('変換タスクを開始しました！', 'success'); resetConverterSelection(); displayUserConversions();
            } catch (e) { console.error(e); showToast(e.message, 'error'); } finally { setLoadingState(startConversionButton, false); } // Reset to default text
        });
        const cropperUploadSection = document.getElementById('cropper-upload-section'), cropperMainSection = document.getElementById('cropper-main-section'), cropperImage = document.getElementById('cropper-image'), cropperDropzone = document.getElementById('cropper-dropzone'), cropperFileInput = document.getElementById('cropper-file-input'), cropBtn = document.getElementById('crop-btn'), cropperResetBtn = document.getElementById('cropper-reset-btn'), cropperChangeImageBtn = document.getElementById('cropper-change-image-btn');
        let cropper = null, cropperSourceFile = null;
        function initCropper(imgEl) { if (cropper) cropper.destroy(); cropper = new Cropper(imgEl, { viewMode: 1, dragMode: 'move', autoCropArea: 0.8, restore: false, modal: true, guides: true, center: true, highlight: false, cropBoxMovable: true, cropBoxResizable: true, toggleDragModeOnDblclick: false }); }
        function handleCropperFileSelection(file) { if (!file) return resetCropper(); const maxSize = MAX_IMAGE_SIZE_MB * 1024 * 1024; if (!file.type.startsWith('image/')) { showToast('無効なファイルタイプです。画像を選択してください。', 'error'); return resetCropper(); } if (file.size > maxSize) { showToast(`画像が ${MAX_IMAGE_SIZE_MB}MB の制限を超えています`, 'error'); return resetCropper(); } cropperSourceFile = file; const reader = new FileReader(); reader.onload = (e) => { cropperImage.src = e.target.result; cropperUploadSection.classList.add('hidden'); cropperMainSection.classList.remove('hidden'); setTimeout(() => { initCropper(cropperImage); showToast('画像ロード完了。トリミング範囲を調整してください。', 'info'); }, 100); }; reader.onerror = () => { showToast('画像ファイルの読み込みに失敗しました。', 'error'); resetCropper(); }; reader.readAsDataURL(file); }
        function resetCropper() { if (cropper) cropper.destroy(); cropper = null; cropperImage.src = '#'; cropperFileInput.value = ''; cropperSourceFile = null; cropperUploadSection.classList.remove('hidden'); cropperMainSection.classList.add('hidden'); }
        cropperDropzone.addEventListener('dragover', (e) => { e.preventDefault(); cropperDropzone.classList.add('hover'); });
        cropperDropzone.addEventListener('dragleave', () => cropperDropzone.classList.remove('hover'));
        cropperDropzone.addEventListener('drop', (e) => { e.preventDefault(); cropperDropzone.classList.remove('hover'); if (e.dataTransfer.files?.[0]) handleCropperFileSelection(e.dataTransfer.files[0]); });
        document.getElementById('cropper-browse-files').addEventListener('click', () => cropperFileInput.click()); cropperFileInput.addEventListener('change', (e) => handleCropperFileSelection(e.target.files?.[0])); cropperChangeImageBtn.addEventListener('click', resetCropper); cropperResetBtn.addEventListener('click', () => { if (cropper) cropper.reset(); });
        cropBtn.addEventListener('click', () => {
            if (!cropper || !cropperSourceFile) return; setLoadingState(cropBtn, true);
            try {
                const canvas = cropper.getCroppedCanvas({ imageSmoothingEnabled: true, imageSmoothingQuality: 'high', fillColor: '#000' }); // Black fill for dark theme
                let mime = 'image/png', quality = undefined, originalType = cropperSourceFile.type; // Default to PNG for transparency
                if (originalType === 'image/jpeg') { mime = 'image/jpeg'; quality = 0.92; }
                else if (originalType === 'image/webp') { mime = 'image/webp'; quality = 0.9; }
                const extension = mime.split('/')[1], filename = `${cropperSourceFile.name.replace(/\.[^/.]+$/, "")}_cropped.${extension}`;
                canvas.toBlob((blob) => { if (!blob) { showToast('トリミング画像の作成に失敗しました。', 'error'); setLoadingState(cropBtn, false); return; } const url = URL.createObjectURL(blob), a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showToast('画像をトリミングし、ダウンロードを開始しました！', 'success'); setLoadingState(cropBtn, false); }, mime, quality);
            } catch (e) { console.error("Cropping failed:", e); showToast(`トリミング失敗: ${e.message}`, 'error'); setLoadingState(cropBtn, false); }
        });
        const squareUploadSection = document.getElementById('square-upload-section'), squareMainSection = document.getElementById('square-main-section'), squareDropzone = document.getElementById('square-dropzone'), squareFileInput = document.getElementById('square-file-input'), squareSourceImage = document.getElementById('square-source-image'), squarePreviewContainer = document.getElementById('square-preview-container'), squarePreviewCanvas = document.getElementById('square-preview-canvas'), squareProcessBtn = document.getElementById('square-process-btn'), squareChangeImageBtn = document.getElementById('square-change-image-btn'), squareAspectRatioSelect = document.getElementById('square-aspect-ratio'), colorSwatchContainer = document.getElementById('color-swatch-container'), squareBgOptions = document.querySelectorAll('input[name="square-bg-option"]');
        let squareSourceFile = null, selectedCustomColor = '#000000'; // Default to black bg
        const presetColors = ['#000000', '#FFFFFF', '#FF7B00', '#333333', '#111111', '#2ECC40', '#FF4136', '#0074D9']; // Adjusted presets
        const aspectRatios = [{ name: "画像に合わせる (オリジナル)", ratio: NaN }, { name: "正方形 (1:1)", ratio: 1 }, { name: "標準 (4:3)", ratio: 4/3 }, { name: "ワイド (16:9)", ratio: 16/9 }, { name: "シネマ (21:9)", ratio: 21/9 }, { name: "縦長 (9:16)", ratio: 9/16 }, { name: "縦長 (2:3)", ratio: 2/3 }, { name: "Twitterヘッダー (3:1)", ratio: 3 }, { name: "Facebookカバー (~2.6:1)", ratio: 820/312 }, { name: "YouTubeバナー (16:9)", ratio: 16/9 }]; // Japanese names
        function populateAspectRatioOptions() { squareAspectRatioSelect.innerHTML = ''; aspectRatios.forEach(ar => { const opt = document.createElement('option'); opt.value = ar.ratio; opt.textContent = ar.name; squareAspectRatioSelect.appendChild(opt); }); squareAspectRatioSelect.value = "NaN"; }
        function populateColorSwatches() {
            colorSwatchContainer.innerHTML = ''; presetColors.forEach(color => {
                const swatch = document.createElement('button'); swatch.type = 'button'; swatch.className = 'color-swatch'; swatch.style.backgroundColor = color; swatch.dataset.color = color; swatch.setAttribute('aria-label', `背景色 ${color} を選択`); if (color === selectedCustomColor) swatch.classList.add('selected');
                swatch.addEventListener('click', () => {
                    selectedCustomColor = color; colorSwatchContainer.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected')); swatch.classList.add('selected'); document.querySelector('input[name="square-bg-option"][value="custom"]').checked = true; drawSquareCenteredImage();
                }); colorSwatchContainer.appendChild(swatch);
            });
            // Ensure the default selected swatch has the class
            const defaultSwatch = colorSwatchContainer.querySelector(`.color-swatch[data-color="${selectedCustomColor}"]`);
            if (defaultSwatch && !defaultSwatch.classList.contains('selected')) {
                 colorSwatchContainer.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                 defaultSwatch.classList.add('selected');
            }
        }
        function getBorderColor(imgEl) { try { const canvas = document.createElement('canvas'); canvas.width = 1; canvas.height = 1; const ctx = canvas.getContext('2d', { willReadFrequently: true }); ctx.drawImage(imgEl, 0, 0, 1, 1, 0, 0, 1, 1); const [r, g, b] = ctx.getImageData(0, 0, 1, 1).data; return `rgb(${r}, ${g}, ${b})`; } catch (e) { console.error("境界色の取得失敗:", e); return '#000000'; } } // Default black
        function drawSquareCenteredImage() {
            if (!squareSourceImage.src || squareSourceImage.src.startsWith('#') || !squareSourceImage.naturalWidth) return;
            const img = squareSourceImage, canvas = squarePreviewCanvas, ctx = canvas.getContext('2d'), container = squarePreviewContainer; const imgW = img.naturalWidth, imgH = img.naturalHeight, imgRatio = imgW / imgH; let targetRatio = parseFloat(squareAspectRatioSelect.value); let canvasW, canvasH;
            if (isNaN(targetRatio)) { canvasW = imgW; canvasH = imgH; targetRatio = imgRatio; } else { if (imgRatio > targetRatio) { canvasW = imgW; canvasH = canvasW / targetRatio; } else { canvasH = imgH; canvasW = canvasH * targetRatio; } }
            // Limit canvas size for performance in preview if needed, but keep aspect ratio
            const maxDim = 1000;
            if (canvasW > maxDim || canvasH > maxDim) {
                if (canvasW > canvasH) { canvasH = Math.round(canvasH * (maxDim / canvasW)); canvasW = maxDim; }
                else { canvasW = Math.round(canvasW * (maxDim / canvasH)); canvasH = maxDim; }
            } else {
                 canvasW = Math.round(canvasW); canvasH = Math.round(canvasH);
            }

            canvas.width = canvasW; canvas.height = canvasH;
            // Set container aspect ratio for layout
            container.style.paddingBottom = `${(canvasH / canvasW) * 100}%`; // Use padding-bottom trick for aspect ratio

            const bgOpt = document.querySelector('input[name="square-bg-option"]:checked').value; const bgColor = bgOpt === 'border' ? getBorderColor(img) : selectedCustomColor;
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Calculate destination size respecting target aspect ratio
            let drawW, drawH, drawX, drawY;
            if (imgRatio > targetRatio) { // Image wider than target
                drawW = canvas.width;
                drawH = drawW / imgRatio;
                drawX = 0;
                drawY = (canvas.height - drawH) / 2;
            } else { // Image taller than target (or same)
                drawH = canvas.height;
                drawW = drawH * imgRatio;
                drawX = (canvas.width - drawW) / 2;
                drawY = 0;
            }

            ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, drawX, drawY, drawW, drawH);
        }
        function handleSquareFileSelection(file) { if (!file) return resetSquareCenter(); const maxSize = MAX_IMAGE_SIZE_MB * 1024 * 1024; if (!file.type.startsWith('image/') || !['image/png', 'image/jpeg', 'image/webp'].includes(file.type)) { showToast('無効なファイルタイプ (PNG, JPG, WEBPのみ)。', 'error'); return resetSquareCenter(); } if (file.size > maxSize) { showToast(`画像が ${MAX_IMAGE_SIZE_MB}MB の制限を超えています`, 'error'); return resetSquareCenter(); } squareSourceFile = file; const reader = new FileReader(); reader.onload = (e) => { squareSourceImage.onload = () => { squareUploadSection.classList.add('hidden'); squareMainSection.classList.remove('hidden'); populateColorSwatches(); drawSquareCenteredImage(); showToast('画像ロード完了。オプションを調整してください。', 'info'); squareSourceImage.onload = null; }; squareSourceImage.onerror = () => { showToast('画像プレビューの読み込みに失敗しました。', 'error'); resetSquareCenter(); }; squareSourceImage.src = e.target.result; }; reader.onerror = () => { showToast('画像ファイルの読み込みに失敗しました。', 'error'); resetSquareCenter(); }; reader.readAsDataURL(file); }
        function resetSquareCenter() { squareSourceFile = null; squareFileInput.value = ''; squareSourceImage.src = '#'; const ctx = squarePreviewCanvas.getContext('2d'); ctx.clearRect(0, 0, squarePreviewCanvas.width, squarePreviewCanvas.height); squareUploadSection.classList.remove('hidden'); squareMainSection.classList.add('hidden'); document.querySelector('input[name="square-bg-option"][value="border"]').checked = true; selectedCustomColor = '#000000'; // Reset to black
            populateAspectRatioOptions(); // Repopulate might be needed if options change
            populateColorSwatches(); // Reset colors
            squareAspectRatioSelect.value = "NaN";
            squarePreviewContainer.style.paddingBottom = '0'; // Reset aspect ratio trick
            squarePreviewCanvas.width = 1; squarePreviewCanvas.height = 1; // Clear canvas visually
        }
        squareDropzone.addEventListener('dragover', (e) => { e.preventDefault(); squareDropzone.classList.add('hover'); });
        squareDropzone.addEventListener('dragleave', () => squareDropzone.classList.remove('hover'));
        squareDropzone.addEventListener('drop', (e) => { e.preventDefault(); squareDropzone.classList.remove('hover'); if (e.dataTransfer.files?.[0]) handleSquareFileSelection(e.dataTransfer.files[0]); });
        document.getElementById('square-browse-files').addEventListener('click', () => squareFileInput.click()); squareFileInput.addEventListener('change', (e) => handleSquareFileSelection(e.target.files?.[0])); squareChangeImageBtn.addEventListener('click', resetSquareCenter);
        squareBgOptions.forEach(r => r.addEventListener('change', drawSquareCenteredImage)); squareAspectRatioSelect.addEventListener('change', drawSquareCenteredImage);
        squareProcessBtn.addEventListener('click', () => {
            if (!squareSourceFile || !squarePreviewCanvas || squarePreviewCanvas.width <= 1) return; setLoadingState(squareProcessBtn, true); // Use default loading text
            try {
                // Draw final image at full resolution before download
                 const img = squareSourceImage; const canvas = document.createElement('canvas'); // Use temp canvas for full res
                 const ctx = canvas.getContext('2d'); const imgW = img.naturalWidth; const imgH = img.naturalHeight; const imgRatio = imgW / imgH; let targetRatio = parseFloat(squareAspectRatioSelect.value); let canvasW, canvasH;
                 if (isNaN(targetRatio)) { canvasW = imgW; canvasH = imgH; targetRatio = imgRatio; } else { if (imgRatio > targetRatio) { canvasW = imgW; canvasH = canvasW / targetRatio; } else { canvasH = imgH; canvasW = canvasH * targetRatio; } }
                 canvas.width = Math.round(canvasW); canvas.height = Math.round(canvasH);
                 const bgOpt = document.querySelector('input[name="square-bg-option"]:checked').value; const bgColor = bgOpt === 'border' ? getBorderColor(img) : selectedCustomColor;
                 ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
                 let drawW, drawH, drawX, drawY;
                 if (imgRatio > targetRatio) { drawW = canvas.width; drawH = drawW / imgRatio; drawX = 0; drawY = (canvas.height - drawH) / 2; }
                 else { drawH = canvas.height; drawW = drawH * imgRatio; drawX = (canvas.width - drawW) / 2; drawY = 0; }
                 ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high'; ctx.drawImage(img, drawX, drawY, drawW, drawH);

                 // --- Blob creation and download ---
                let mime = 'image/png', quality = undefined, originalType = squareSourceFile.type;
                if (originalType === 'image/jpeg') { mime = 'image/jpeg'; quality = 0.92; }
                else if (originalType === 'image/webp') { mime = 'image/webp'; quality = 0.9; }
                const extension = mime.split('/')[1], filename = `${squareSourceFile.name.replace(/\.[^/.]+$/, "")}_fitted.${extension}`;
                canvas.toBlob((blob) => { if (!blob) { showToast('画像Blobの作成に失敗しました。', 'error'); setLoadingState(squareProcessBtn, false); return; } const url = URL.createObjectURL(blob), a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showToast('処理済み画像のダウンロードを開始しました！', 'success'); setLoadingState(squareProcessBtn, false); }, mime, quality);
            } catch (e) { console.error("Aspect Fit failed:", e); showToast(`処理失敗: ${e.message}`, 'error'); setLoadingState(squareProcessBtn, false); }
        });
        const activePolls = {};
        async function fetchAndUpdateTasks(type) {
            const idField = getTaskIdField(type), statusEndpointBase = type === 'download' ? `${apiBaseUrl}/status` : `${apiBaseUrl}/conversion/convert`;
            let tasks = getUserTasks(type); const activeTasks = tasks.filter(t => t.status && !['completed', 'failed', 'canceled'].includes(t.status)); if (activeTasks.length === 0) return tasks;
            try {
                await Promise.all(activeTasks.map(async (task) => {
                    const taskId = task[idField]; try {
                        const response = await fetch(`${statusEndpointBase}/${taskId}`); if (response.ok) { const updatedTask = await response.json(); saveUserTask(type, updatedTask); } else if (response.status === 404) saveUserTask(type, { ...task, status: 'failed', error_message: 'Task not found' }); else console.warn(`Update status ${response.status} for ${type} ${taskId}`);
                    } catch (e) { console.error(`Error updating ${type} ${taskId}:`, e); /* Optionally update task status to error */ }
                }));
             } catch (e) {
                 console.error(`Error fetching updates for ${type}:`, e);
             }
            return getUserTasks(type); // Return potentially updated tasks
        }
        async function displayUserTasks(type) {
            const containerId = type === 'download' ? 'downloads-container' : 'conversions-container', container = document.getElementById(containerId), emptyIconClass = type === 'download' ? 'fa-download' : 'fa-exchange-alt'; container.innerHTML = `<div class="empty-state"><i class="fas fa-spinner fa-spin" style="margin-right: 8px;"></i>ロード中...</div>`; try {
                let tasks = await fetchAndUpdateTasks(type); container.innerHTML = ''; if (!tasks || tasks.length === 0) { container.innerHTML = `<div class="empty-state"><div class="empty-state-icon"><i class="fas ${emptyIconClass}"></i></div><p>${type === 'download' ? 'ダウンロード履歴なし' : '変換履歴なし'}</p></div>`; return; }
                tasks.sort((a, b) => new Date(b.created_at || 0) - new Date(a.created_at || 0)).forEach(task => { const el = createTaskElement(task, type); if (el) container.appendChild(el); });
            } catch (e) { console.error(`Display error ${type}:`, e); container.innerHTML = `<p style="color:#FF4136; text-align:center; padding: 1rem;">${type === 'download' ? 'ダウンロード' : '変換'}リストの読み込みに失敗しました</p>`; showToast(`${type === 'download' ? 'ダウンロード' : '変換'}リストのエラー`, 'error'); }
        }
        const displayUserDownloads = () => displayUserTasks('download');
        const displayUserConversions = () => displayUserTasks('conversion');
        const taskTemplate = document.getElementById('task-template');
        function createTaskElement(task, type) {
            if (!taskTemplate?.content) return null; const element = taskTemplate.content.cloneNode(true).children[0]; const taskId = task[getTaskIdField(type)], status = task.status || 'unknown'; element.dataset.id = taskId; element.dataset.type = type;
            element.querySelector('.task-title').textContent = task.title || `無題の${type}`; // Japanese Untitled
            const infoParts = [];
            if (type === 'conversion') { if (task.input_format) infoParts.push(`入力: ${task.input_format.toUpperCase()}`); if (task.output_format) infoParts.push(`出力: ${task.output_format.toUpperCase()}`);}
            else if (type === 'download') { if (task.format_id) infoParts.push(`形式: ${task.format_id}`); if (task.mode) infoParts.push(`モード: ${task.mode}`); }
            if (task.file_size) infoParts.push(`サイズ: ${formatFileSize(task.file_size)}`); element.querySelector('.task-info').textContent = infoParts.join(' | ') || '詳細なし';

            let iconCls = 'fa-file'; // Default
             if (type === 'conversion') iconCls = 'fa-exchange-alt';
             else if (type === 'download') iconCls = task.mode === 'audio-only' ? 'fa-file-audio' : 'fa-youtube';
             element.querySelector('.task-icon i').className = `fas ${iconCls}`; // Set icon class

            const statusEl = element.querySelector('.task-status'), progressEl = element.querySelector('.task-progress'), errorEl = element.querySelector('.task-error-info');
            statusEl.textContent = status; // Raw status text might be better than capitalize
            statusEl.className = `task-status ${status}`; // Use status as class for CSS targeting
             progressEl.classList.add('hidden'); errorEl.classList.add('hidden'); // Reset visibility

            if (status === 'failed' || status === 'canceled') { if (task.error_message) { errorEl.textContent = `エラー: ${task.error_message}`; errorEl.classList.remove('hidden'); } }
            else if (status === 'processing' || status === 'downloading') { progressEl.classList.remove('hidden'); const progress = Math.max(0, Math.min(100, Math.round(task.progress || 0))); progressEl.querySelector('.progress-bar').style.width = `${progress}%`; progressEl.querySelector('.progress-text').textContent = `${progress}%`; setupTaskPolling(taskId, type, element); }

            const actionsEl = element.querySelector('.task-actions'); actionsEl.innerHTML = '';
            if (status === 'completed') { const dlBtn = document.createElement('button'); dlBtn.title = 'ファイルをダウンロード'; dlBtn.innerHTML = '<i class="fas fa-download"></i>'; dlBtn.addEventListener('click', () => { window.open(type === 'conversion' ? `${apiBaseUrl}/conversion/download-conversion/${taskId}` : `${apiBaseUrl}/download/${taskId}`, '_blank'); showToast(`ダウンロードを開始しています...`, 'info'); }); actionsEl.appendChild(dlBtn); }
            // Always add delete button
            const delBtn = document.createElement('button'); delBtn.title = 'タスクを削除'; delBtn.innerHTML = '<i class="fas fa-trash-alt"></i>'; delBtn.classList.add('delete-btn'); // Add class for hover effect
            delBtn.addEventListener('click', () => {
                 showModal(`${type === 'download' ? 'ダウンロード' : '変換'} '${task.title || taskId}' を削除しますか？`, async () => {
                     const wasPolling = activePolls[taskId];
                     element.remove(); deleteUserTask(type, taskId);
                     showToast(`${type === 'download' ? 'ダウンロード' : '変換'}を削除しました`, 'info');
                     if (wasPolling) clearInterval(activePolls[taskId]); delete activePolls[taskId];
                     const containerId = type === 'download' ? 'downloads-container' : 'conversions-container', cont = document.getElementById(containerId);
                     if (cont && !cont.querySelector('.task-item')) {
                          const emptyIcon = type === 'download' ? 'fa-download' : 'fa-exchange-alt';
                          cont.innerHTML = `<div class="empty-state"><div class="empty-state-icon"><i class="fas ${emptyIcon}"></i></div><p>${type === 'download' ? 'ダウンロード履歴なし' : '変換履歴なし'}</p></div>`;
                     }
                     const delEp = type === 'conversion' ? `${apiBaseUrl}/conversion/convert/${taskId}` : `${apiBaseUrl}/youtube/${taskId}`; try { await fetch(delEp, { method: 'DELETE' }); } catch (e) { console.warn(`Server delete failed ${type} ${taskId}:`, e); }
                 });
            }); actionsEl.appendChild(delBtn); return element;
        }
        function setupTaskPolling(taskId, type, element) {
            if (activePolls[taskId]) return; // Already polling
            // console.log(`Starting poll for ${type} ${taskId}`);
             const intervalId = setInterval(async () => {
                const statusEp = type === 'conversion' ? `${apiBaseUrl}/conversion/convert/${taskId}` : `${apiBaseUrl}/status/${taskId}`;
                try {
                    const currentElement = document.querySelector(`.task-item[data-id="${taskId}"][data-type="${type}"]`);
                    if (!currentElement) {
                        // console.log(`Element for ${type} ${taskId} not found, stopping poll.`);
                        clearInterval(intervalId); delete activePolls[taskId]; return;
                    }
                    const response = await fetch(statusEp);
                    if (!response.ok) {
                        let status = 'failed', msg = `ポーリングエラー ${response.status}`; if (response.status === 404) msg = 'タスクが見つかりません';
                         saveUserTask(type, { [getTaskIdField(type)]: taskId, status, error_message: msg });
                         console.warn(`Polling failed for ${type} ${taskId}, status ${response.status}`);
                         clearInterval(intervalId); delete activePolls[taskId];
                         if (type === 'conversion') displayUserConversions(); else displayUserDownloads(); // Refresh list on error
                         return;
                     }
                     const data = await response.json();
                     saveUserTask(type, data); // Save latest status

                     // Update UI elements if still processing
                     const progress = Math.max(0, Math.min(100, Math.round(data.progress || 0)));
                     const pBar = currentElement.querySelector('.progress-bar');
                     const pTxt = currentElement.querySelector('.progress-text');
                     if (pBar) pBar.style.width = `${progress}%`;
                     if (pTxt) pTxt.textContent = `${progress}%`;
                     const statusEl = currentElement.querySelector('.task-status');
                      if (statusEl && statusEl.textContent !== data.status) {
                         statusEl.textContent = data.status;
                         statusEl.className = `task-status ${data.status}`; // Update class based on new status
                      }

                     if (['completed', 'failed', 'canceled'].includes(data.status)) {
                         // console.log(`Polling finished for ${type} ${taskId}, status: ${data.status}`);
                         clearInterval(intervalId); delete activePolls[taskId];
                         showToast(`${type === 'download' ? 'ダウンロード' : '変換'}タスク ${data.status === 'completed' ? '完了' : '失敗'}！`, data.status === 'completed' ? 'success' : 'error');
                         // Refresh the entire list to update actions etc.
                         if (type === 'conversion') displayUserConversions(); else displayUserDownloads();
                     }
                 } catch (e) {
                     console.error(`Polling error for ${type} ${taskId}:`, e);
                     // Optional: Stop polling on network error? Or keep trying?
                     // clearInterval(intervalId); delete activePolls[taskId];
                 }
            }, POLL_INTERVAL_MS);
            activePolls[taskId] = intervalId; // Store interval ID
        }
        document.getElementById('refresh-downloads').addEventListener('click', displayUserDownloads);
        document.getElementById('refresh-conversions').addEventListener('click', displayUserConversions);
        document.getElementById('clear-downloads').addEventListener('click', () => showModal('すべてのダウンロード履歴を消去しますか？この操作は元に戻せません。', () => { clearUserTasks('download'); displayUserDownloads(); showToast('ダウンロード履歴を消去しました', 'info'); }));
        document.getElementById('clear-conversions').addEventListener('click', () => showModal('すべての変換履歴を消去しますか？この操作は元に戻せません。', () => { clearUserTasks('conversion'); displayUserConversions(); showToast('変換履歴を消去しました', 'info'); }));

        // --- Initialisation ---
        document.addEventListener('DOMContentLoaded', () => {
            // Remplacer la date dans le footer (simple remplacement texte)
            document.getElementById('current-year').textContent = new Date().getFullYear();

            populateAspectRatioOptions();
            populateColorSwatches(); // Populate swatches initially

            displayUserDownloads(); displayUserConversions();

            // Initialiser les états UI
            updateConverterUI(); resetCropper(); resetSquareCenter();

            initializeTabFromUrl(); // Active le bon onglet au chargement
        });
    </script>
</body>
</html>